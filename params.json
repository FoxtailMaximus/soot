{"name":"Soot","tagline":"clojure hearthstone","body":"# c\r\n\r\nonly build on windows x64 c99 gcc (i use tdm-gcc); could be rewritten for not\r\nwindows / not 64-bit, but meh\r\n\r\noh yeah, -nostdlib #yolo\r\n\r\n# clojure\r\n\r\n- tray contains mana crystals (current/max \"spent+unspent\")\r\n- hero character has health, armor, hero power, weapon?\r\n- hand contains cards, limit of 10 (new cards destroyed)\r\n- board contains minions, limit of 7 per side (new minions destroyed)\r\n- deck contains undrawn cards, starts at 30; at 0, fatigue kicks in, damaging\r\nthe player (1 2 3 4 5 ... damage) on any attempted draw\r\n\r\nminions contain:\r\n  - Name, Cost, Attack, Current Health, Maximum Health\r\n  - Type (Beast, Demon, Dragon, Murloc, Pirate, Totem, General)\r\n  - Properties (Taunt, Windfury, Charge, Stealth, Divine Shield)\r\n  - Effects (event-based e.g. Battlecry, Deathrattle, Enrage, EoT/BoT)\r\n  - External buffs (e.g. Spell Damage)\r\n\r\nwords in fn names:\r\n\r\n- my: refers to the current controller in the game state or to the controller of\r\nthe minion for which an action is being performed\r\n- opponent: the opposite of 'my'\r\n\r\nfunctions:\r\n\r\n- game state is always first arg\r\n- functions that don't return a game state are normally called directly, whereas\r\nfunctions that do return a game state are generally partially applied\r\n- filters are common\r\n- values/functions interchangeable (call the function against the current game\r\nstate to get the current value)\r\n\r\ncard states:\r\n - :undrawn\r\n - :drawn\r\n - :played\r\n - :dead\r\n\r\ncard types:\r\n - :weapon\r\n - :character (includes :hero, :minion)\r\n - :hero\r\n - :minion\r\n - :spell\r\n - :hero-power\r\n\r\ntempted to remove `-target` from loads of function names, need to double check\r\n\"normativity\" of that though\r\n\r\nmight replace 'opponent' with 'enemy'\r\n\r\nlots of todos in cards:  saving them for when I have a complete picture of the\r\nstructure of the game state\r\n\r\nin give- and in :aura, :health is assumed to buff :max-health as well (as\r\notherwise it'd be a restore)\r\n\r\na target is damaged if it is below its original health? test with warrior...\r\n\r\nreally need to distinguish spell damage buffed abilities.  arcane missiles needs\r\na way to send more missiles by spell damage, too, (same with avenging wrath\r\netc.)\r\n\r\nredo it in C once we find out that the JVM won't do it for us.\r\n\r\n## function notes\r\n\r\n### targeting\r\n\r\n- `(target filter expr)`; filter may be a single or a coll of keywords and/or\r\nfunctions.  functions are applied with the contextual target as the sole\r\nargument and should return a boolean (true include/false exclude).  colls are\r\ncombined using logical and.  when filtering cards, cards are filtered for :state\r\n:played and :character unless an overriding keyword is provided.  an empty\r\nvector allows the default filtering.  this behavior belongs to filter-all. expr\r\nfunctions are applied with the state as the sole argument, and this state\r\ncontains the target as a part of its context.  often for target, colls are used\r\nfor single keywords just cause it looks nicer.\r\n\r\n- `(target-random)`; while (target ...) will require input from the user if more\r\nthan one viable target is found, (target-random ...) will choose randomly from\r\nviable targets.  if a number is supplied to the filter coll for target-random,\r\nthat number of ''unique'' targets will be chosen.  a second expr may be supplied\r\n\r\n`(target-random filter expr fallback)` that is called for the times where a\r\nviable target does not exist.\r\n\r\n- `(target-all)`; (target-all ...) applies expr to every viable target, not just\r\none.\r\n\r\n### choose one\r\n\r\n- `(choose one two)`; requires input to choose between two possible spells.\r\nspells can be numbers or strings referring to ids or names of the spell to cast\r\n\r\n### combo\r\n\r\n- `(combo normal-expr combo-expr)`; wrapper for rogue combo spells.  combo on\r\nminions is an optional battlecry, but on spells the spell effect branches based\r\non combo state, so it's sometimes helpful to describe it as a branch instead of\r\nas a property of the card (although :combo can be used on spells as well)\r\n\r\n### verbs on cards\r\n\r\n- draw-: undrawn -> drawn\r\n- summon-: (undrawn, drawn, nil) -> played; summon- is often called with a\r\nstring, number, or collection of strings/numbers, in which case cards are\r\ncreated before being summoned.\r\n- play-: drawn -> played\r\n- return-: played -> drawn\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}